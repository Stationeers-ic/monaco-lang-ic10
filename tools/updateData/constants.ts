import { writeFile } from "node:fs/promises"
import z from "zod"
import { kindEnum } from "../../src/enums"
import { row } from "."

export default async function updateLogicAndConstants() {
	const constants = await fetch("https://assets.ic10.dev/languages/EN/constants.json").then((res) => res.json())

	const descriptions: Map<string, string> = await fetch("https://assets.ic10.dev/languages/EN/logics.json")
		.then((res) => res.json())
		.then((data) => {
			const map: Map<string, string> = new Map()
			for (const entry of data.data) {
				if (!entry.name || entry.name.length === 0) continue
				if (!entry.description || entry.description.length === 0) continue
				map.set(entry.name, entry.description)
			}
			return map
		})
	const constant = z.object({
		literal: z.string().min(1),
		description: z.string().optional(),
		value: z.number().or(z.nan()).or(z.literal(Infinity)).or(z.literal(-Infinity)),
		deprecated: z.boolean().optional(),
		kind: z.union(Object.values(kindEnum).map((v) => z.literal(v))),
	})

	type constant = z.infer<typeof constant>
	const constantList: Map<string, constant> = new Map()
	const logicList: Map<string, constant> = new Map()

	// parce constants if entry starts with Logic add it to logic else to consts
	// skip if canUseAsConst is false

	function getEntryLiteral(entry: any): constant | null {
		if (entry.canUseAsConst === false) return null

		const result = {
			literal: entry.literal,
			value: Number(entry.value),
			deprecated: entry.deprecated || undefined,
			kind:
				entry.referenceType in kindEnum
					? kindEnum[entry.referenceType as keyof typeof kindEnum]
					: entry.referenceType,
		}
		if (Number.isNaN(result.value) && entry.value !== "NaN") {
			console.warn(`Invalid constant value: ${entry.literal} got ${entry.value}`)
			return null
		}
		const parseResult = constant.safeParse(result)
		if (!parseResult.success) {
			console.warn(`Failed to parse constant: ${entry.literal}`, parseResult.error.message)
			return null
		}
		return parseResult.data
	}

	for (const raw of Object.entries(constants)) {
		const entry = raw[1]
		const parsed = getEntryLiteral(entry)
		if (!parsed) continue
		if (parsed.literal !== raw[0]) {
			console.log(parsed.literal, raw[0])
			continue
		}
		if (parsed.literal.startsWith("Logic")) logicList.set(parsed.literal, parsed)
		else constantList.set(parsed.literal, parsed)
	}
	// got x logicList and constantList
	console.log(`Fetched ${constantList.size} constant entries`)
	console.log(`Fetched ${logicList.size} logic entries`)
	type nestedData = { [key: string]: constant | nestedData }

	function writeTree(tree: nestedData, constantValues: string[], path: string = "", indent = 1): string {
		let result = ""
		// use path and constantValues to determine if end reached
		const entries = Object.entries(tree)
		for (const [key, value] of entries) {
			if (constantValues.includes(path + key)) {
				const constantValue = value as constant
				result += row(`${key}: {`, indent)
				result += row(`literal: ${JSON.stringify(constantValue.literal)},`, indent + 1)
				result += row(`value: ${constantValue.value},`, indent + 1)
				if (constantValue.deprecated) result += row(`deprecated: true,`, indent + 1)
				result += row(`kind: ${constantValue.kind},`, indent + 1)
				result += row(`},`, indent)
				continue
			}
			if (typeof value === "object") {
				result += row(`${key}: {`, indent)
				result += writeTree(value as nestedData, constantValues, `${path + key}.`, indent + 1)
				result += row(`},`, indent)
			}
		}
		return result
	}
	function makeTree(constants: Map<string, constant>) {
		const tree: nestedData = {}
		for (const constant of constants.values()) {
			const parts = constant.literal.split(".")
			let current: nestedData = tree
			for (let i = 0; i < parts.length; i++) {
				const part = parts[i]
				if (i === parts.length - 1) {
					current[part] = constant
				} else {
					if (!(part in current)) {
						current[part] = {}
					}
					current = current[part] as nestedData
				}
			}
		}
		return tree
	}

	function generateDataFile(constants: Map<string, constant>): string {
		const tree = makeTree(constants)
		let fileContent = `// This file is auto-generated by tools/updateData/index.ts\n`
		fileContent += `import type { nestedData } from "."\n`
		fileContent += `export default {\n`
		fileContent += writeTree(
			tree,
			[...constants.values()].map((c) => c.literal),
		)
		fileContent += `} satisfies nestedData as nestedData\n`

		return fileContent
	}

	const constantsFileContent = generateDataFile(constantList)
	const logicFileContent = generateDataFile(logicList)

	await writeFile("src/data/constants.ts", constantsFileContent, "utf-8")
	await writeFile("src/data/logic.ts", logicFileContent, "utf-8")
}
